# 아이템50. 컬렉션 처리 단계 수를 제한하라
모든 컬렉션 처리 메서드는 비용이 많이 듭니다.<br>
표준 컬렉션 처리는 내부적으로 요소들을 활용해 반복을 돌며 내부적으로 계산을 위해 추가적인 컬렉션을 만들어 사용합니다.<br>
시퀀스 처리도 시퀀스 전체를 랩하는 객체가 만들어지며 조작을 위해서 또 다른 추가적인 객체를 만들어 냅니다.<br>
두 처리 모두 요소의 수가 많다면 꽤 큰 비용이 들어갑니다.<br>
적절한 메서드를 활용해서 컬렉션 처리 단계 수를 적절하게 제한하는 것이 좋습니다.

[fun01.kt](fun01.kt)
컬렉션 처리와 관련해서 비효율적인 코드를 작성하는 이유는 그것이 필요 없다고 생각해서가 아니라, 어떤 메서드가 있는지 몰라서인 경우가 많습니다.<br>
따라서 어떤 메서드가 있는지 확인해 보는 것이 좋습니다.

| 이 코드보다는                                                  | 이 코드가 좋습니다                              |
|----------------------------------------------------------|-----------------------------------------|
| .filter { it != null }.map { it!! }                      | .filterNotNull()                        |
| .map { ... }.filterNotNull()                             | .mapNotNull { ... }                     |
| .map { ... }.joinToString()                              | .joinToString { ... }                   |
| .filter { ... }.filter { ... }                           | .filter { ... && ... }                  |
| .filter { it is Type }.map { it as Type }                | .filterIsInstance< Type>()              |
| .sortedBy { ... }.sortedBy { ... }                       | .sortedWith( compareBy( {...}, {...} )) |
| listOf(...).filterNotNull()                              | listOfNotNull(...)                      |
| .withIndex().filter { (i, e) -> { ... }.map { it.value } | .filterIndexed { i, e -> ... }          |


## 정리
대부분의 컬렉션 처리 단계는 '전체 컬렉션에 대한 반복'과 '중간 컬렉션 생성'이라는 비용이 발생합니다.<br>
이 비용은 적절한 컬렉션 처리 함수들을 활용해서 줄일 수 있습니다.
