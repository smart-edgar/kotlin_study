# 아이템49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

Iterable과 Sequence는 비슷해 보이지만 완전히 다른 목적으로 설계되어서 완전히 다른 형태로 동작합니다.<br>
Sequence는 지연(lazy) 처리 됩니다.<br>
따라서 시퀀스 처리 함수들을 사용하면 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴됩니다.<br>
최종적인 계산은 toList 또는 count 등의 최종 연산이 이루어질 때 수행됩니다.<br>
반면 Iterable은 처리 함수를 사용할 때마다 연산이 이루어져 List가 만들어집니다.

정리하면 컬렉션 처리 연산은 호출할 때 연산이 이루어집니다. 반면 시퀀스 처리 함수는 최종 연산이 이루어지기 전까지는 각 단계에서 연산이 일어나지 않습니다.<br>
시퀀스 처리 함수 filter는 중간 연산입니다. 따라서 어떠한 연산도 처리하지 않고 기존의 시퀀스를 필터링하는 데코레이터만 설치합니다.<br>
실질적인 필터링 처리는 toList 등과 같은 최종 연산을 할때 이루어집니다.

```
         <--      중간 연산자      -->
sequence.map { ... }.filter { ... }.toList()
                                   < 최종연산 >
```
[fun02.kt](fun02.kt)

시퀀스의 지연 처리는 다음과 같은 장점을 갖습니다.
- 자연스러운 처리 순서를 유지합니다.
- 최소한만 연산합니다.
- 무한 시퀀스 형태로 사용할 수 있습니다.
- 각각의 단계에서 컬렉션을 만들어 내지 않습니다.

## 순서의 중요성
Iterable 처리와 Sequence 처리는 연산의 순서가 달라지면 다른 결과가 나옵니다.<br>
시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용합니다.<br>
이를 element-by-element order 또는 lazy order라고 부릅니다.<br>
반면 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해 나갑니다.<br>
이를 step-by-step order 또는 eager order 라고 부릅니다.
[fun03.kt](fun03.kt)

컬렉션 처리 함수를 사용하지 않고 고전적인 반복문과 조건문을 활용해서 다음과 같은 코드를 구현한다면 이는 시퀀스 처리인 element-by-element order와 같습니다.

따라서 시퀀스 처리에서 사용되는 element-by-element order가 훨씬 자연스러운 처리라고 할수 있습니다.<br>
또한 시퀀스 처리는 기본적인 반복문과 조건문을 사용하는 코드와 같아서ㅓ 아마도 조마낙ㄴ 낮은 레벨 컴파일러 최적화가 처리를 더 빠르게 만들어 줄 수 도 있을것입니다.

## 최소 연산
컬렉션에서 조건에 따라 앞의 요소 10개만 필요한 상황일때
- 이터러블 처리는 모든 요소를 다 처리 후 10개를 사용
- 시퀀스는 앞의 10개만 원하는 처리에 적용

[fun04.kt](fun04.kt)
중간 처리 단계를 모든 요소에 적용 할 필요가 없는 경우에는 시퀀스를 사용하는 것이 좋습니다.<br>
요소를 선택하는 연산으로는 find, first, take, any, all, none, indexOf가 있습니다.

## 무한 시퀀스
시퀀스는 살제로 최종 연산이 일어나기 전까지는 컬렉션에 어떠한 처리도 하지 않습니다.<br>
따라서 무한 시퀀스(infinite sequence)를 만들고 필요한 부분까지만 값을 추출하는 것도 가능합니다.<br>
무한 시퀀스를 만드는 일반적인 방법은 generateSequence 또는 sequence를 사용하는 것 입니다.<br>

먼저 generateSequence는 '첫 번째 요소'와 '그 다음 요소를 계산하는 방법'을 지정해야 합니다.
두번째로 sequence는 중단 함수(suspending function, 코루틴)로 요소들을 지정합니다.<br>
시퀀스 빌더는 중단 함수 내부에서 yield로 값을 하나씩 만들어 냅니다.

[fun05.kt](fun05.kt)
```
println(fibonacci.toList()) //몇개의 값을 활용할지 지정하지 않으면 종료되지 않습니다.
```
따라서 이전 코드처럼 take를 사용하거나 first, find, any, all, none, indexOf와 같은 일부 요소만 선택하는 종결 연산을 활용해야 합니다.<br>
다만 실제로 사용해보면 무한 반복에 빠지는 경우가 생각보다 많습니다.<br>
take와 first 정도만 사용하는 것이 좋습니다.

## 각각의 단계에서 컬렉션을 만들어 내지 않음
표준 컬렉션 처리 함수는 각각의 단계에서 새로운 컬렉션을 만들어 냅니다.<br>
일반적으로 대부분 List 입니다.<br>
각 단계에서 만들어진 결과를 활용하거나 저장할 수 있다는 것은 컬렉션의 장점이지만 각각의 단계에서 결과가 만들어지면서 공간을 차지하는 비용이 든다는 것은 큰 단점입니다.

[fun06.kt](fun06.kt)
크거나 무거운 컬렉션을 처리할 때는 굉장히 큰 비용이 들어갑니다.<br>
극단적인 예로 기가바이트 단위의 파일을 읽어서 컬렉션 처리를 한다면 엄청난 메모리 낭비를 불러 일으킵니다.<br>
그래서 일반적으로 파일을 처리할때는 시퀀스를 활용하는 것 입니다.

1.53Gb의 파일을 중간연산 3회 처리시
- 컬렉션은 대략 4.59Gb -> OOM 발생
- 시퀀스는 대략 728Mb -> 20초미만 처리

시퀀스를 사용하면 메모리 절약 및 성능도 향상 시킬수 있습니다.<br>
컬렉션 처리의 각 단계에서 새로운 컬렉션을 만드는데 비용이 들어갑니다.<br>
크기가 큰 요소를 처리할 수록 비용이 커집니다.<br>
처리 단계가 많아질수록 차이가 커지므로 큰 컬렉션으로 여러 처리 단계를 거쳐야 한다면 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋습니다.

[fun07.kt](fun07.kt)
어느정도 향상이 이루어지는지는 예측하기 어렵지만 20~40% 정도의 성능이 향상됩니다.

## 시퀀스가 빠르지 않은 경우
컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않습니다.<br>
sorted는 Sequence를 List로 변환한 뒤에 sort를 사용해 처리합니다.<br>
문제는 이러한 변환 처리로 인해서 시퀀스가 컬렉션 처리보다 느려진다는 것입니다.(이터러블도 컬렉션 또는 배열은 아니므로 변환처리가 필요해서 차이가 크지는 않습니다)<br>
참고로 무한 시퀀스처럼 시퀀스의 다음 요소를 lazy하게 구하는 시퀀스에 sorted를 적용하면 무한반복에 빠지는 문제가 있습니다.<br>
그래서 시퀀스에서 sorted를 빼야 한다는 의견도 있지만 정렬 처리는 일반적으로 사용되는 처리이므로 시퀀스에도 들어간것입니다.
따라서 <b>무한 시퀀스에 sorted를 사용할수 없다</b>는 결함은 따로 기억해야합니다.

sorted는 Sequence보다 Collection이 더 빠른 희귀한 예 입니다.<br>
다른 처리는 모두 Sequence가 빠르므로 여러 처리가 결합된 경우에는 Collection을 사용하는 것보다 Sequence를 사용하는 것이 더 빠릅니다.

## 자바 스트림의 경우
자바8 부터는 컬렉션 처리를 위해 스트림 기능이 추가되었습니다.<br>
코틀린의 시퀀스와 비슷한 형태로 동작합니다.<br>

자바8의 스트림도 lazy하게 작동하며 마지막 처리 단계에서 연산이 일어납니다.<br>
다만 자바 스트림과 코틀린 시퀀스는 세가지 차이점이 있습니다.
- 코틀린의 시퀀스가 더 많은 처리 함수를 가지고 있습니다. 그리고 사용하기 더 쉽습니다.
- 자바 스트림은 병렬 함수를 사용해서 병렬모드로 실행할 수 있습니다. 멀티코어 환경에서 굉장히 큰 성능 향상을 가져옵니다. 다만 몇가지 결함이 있으므로 주의해야 합니다.
- 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있습니다. 하지만 자바 스트림은 코틀린/JVM에서만 동작하며 그것도 JVM이 8버전 이상일때만 동작합니다.

병렬모드를 사용하지 않는 다면 자바 스트림과 코틀린 시퀀스 중에 어떤것이 더 효율적이라고 단정지어서 이야기 하기 어렵습니다.<br>
병렬모드로 성능적 이득을 얻을 수 있는 곳에서만 자바 스트림을 사용하고ㅡ 이외의 일반적인 경우에는 코틀린 시퀀스를 사용하는 것이 좋다고 생각합니다.<br>
코틀린 stdlib 함수를 사용하면 모든 플랫폼에서 활용할 수 있는 공통 모듈의 코드가 더 깔끔해집니다.

## 코틀린 시퀀스 디버깅
코틀린 시퀀스와 자바 스트림은 모두 단계적으로 요소의 흐름을 추적할수가 있는 디버깅 기능이 지원됩니다.<br>
자바 스트림은 'Java Stream Debugger'라는 이름의 플러그인, 코틀린은 'Kotlin Sequence Debugger'라는 이름의 플러그인으로 활용할수 있습니다.
코틀린은 'Kotlin' 플러그인에 통합되어있습니다.


## 정리
컬렉션과 시퀀스는 같은 처리 메서드를 지원하며 사용하는 형태가 거의 비슷합니다.<br>
일반적으로 데이터를 컬렉션에 저장하므로 시퀀스 처리를 하려면 시퀀스로 변환하는 과정이 필요합니다.<br>
최종적으로 컬렉션 결과를 원하는 경우가 많으므로 시퀀스를 다시 컬렉션으로 변환하는 과정도 필요합니다.<br>
이것이 시퀀스 처리의 단점이라고 할 수 있습니다.<br>
하지만 시퀀스는 lazy하게 처리됩니다.
- 자연스러운 처리 순서를 유지합니다.
- 최소한만 연산합니다.
- 무한 시퀀스 형태로 사용할수 있습니다.
- 각각의 단계에서 컬렉션을 만들어 내지 않습니다.

결과적으로 무거운 객체나 규모가 큰 컬렉션을 여러단계에 걸쳐서 처리할 때는 시퀀스를 사용하는 것이 좋습니다.<br>
상황에 따라서 시퀀스 처리를 활용하면 큰 성능 향상이 있을 수 있습니다.
