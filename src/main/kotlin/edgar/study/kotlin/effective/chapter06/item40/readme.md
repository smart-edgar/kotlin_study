# 아이템40. equals의 규약을 지켜라

코틀린의 Any에는 다음과 같은 잘 설정된 규약들을 가진 메서드들이 있습니다.
- equals
- hashCode
- toString

Any 클래스를 상속받은 모든 메서드는 이러한 규칙을 잘 지켜주는 것이 좋습니다.<br>
이 메서드는 자바때 부터 정의되어 있던 머세드라서 코틀린에서 중요한 위치를 차지하고 있으며 수많은 객체와 함수들이 이 규약에 의존하고 있습니다.


## 동등성
코틀린에는 두가지 종류의 동등성(equality)이 있습니다.
- 구조적 동등성(structural equality) : equals 메서드와 이를 기반으로 만들어진 == 연산자로 확인하는 동등성 입니다.
- 레퍼런스적 동등성(referential equality) : === 연산자로 확인하는 동등성입니다. 두 피연산자가 같은 객체를 가리키면 true를 리턴합니다.

다른 타입의 두 객체를 비교하는 것은 허용되지 않습니다.
같은 타입을 비교하거나 둘이 상속 관계를 갖는 경우에는 비교할 수 있습니다.


## equals가 필요한 이유
equals 메서드는 디폴트로 === 처럼 두 인스턴스가 완전히 같은 객체인지를 비교합니다.<br>
이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미합니다.

동등성을 약간 다른 형태로 표현해야 하는 객체가 있습니다.<br>
data 한정자를 붙여서 데이터 클래스로 정의하면 자동으로 동등성으로 동작합니다.

데이터클래스는 내부에 어떤 값을 갖고 있는지가 중요하므로 데이터 모델을 표현할 때는 data 한정자를 붙입니다.

데이터 클래스의 동등성은 모든 프로퍼티가 아니라 일부 프로퍼티만 비교해야할때도 유용합니다.


## equals의 규약
- 반사적(reflexive) 동작
- 대칭적 동작
- 연속적 동작
- 일관적 동작
- 널과 관련된 동작

추가로 equals, toString, hashCode의 동적은 매우 빠를거라 예측되므로 빠르게 동작해야 합니다.

## URL과 관련된 equals 문제
equals를 잘못 설계한 예로는 java.net.URL이 있습니다.
- 동작이 일관되지 않습니다.
- 일반적으로 equals와 hashCode 처리는 빠를 거라 예상하지만, 네트워크 처리는 괭장히 느립니다.
- 동작 자체에 문제가 많습니다.


## equals 구현하기
특별한 사유가 없는 이상 equals를 직접 구현하는것은 좋지 않습니다.<br>
데이터 클래스로 만들어서 사용하는 것이 좋습니다.

