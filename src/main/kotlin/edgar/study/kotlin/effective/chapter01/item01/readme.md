# 아이템01. 가변성을 제한하라

## 코틀린에서 가변성 제한하기
### 읽기 전용 프로퍼티(val)
val을 사용하여 읽기 전용 프로퍼티를 만들 수 있습니다.<br>
일반적인 방법으로는 값이 변하지 않습니다.
(읽고 쓸 수 있는 프로퍼티는 var로 만듭니다.)<br>
val도 mutable 객체를 담고 있다면 내부적으로 변할 수 있습니다.<br>
코틀린의 프로퍼티는 기본적으로 캡슐화가 되어있고 사용자 정의 접근자(게터와 세터)를 가질 수 있습니다.
(var은 게터와 세터를 모두 제공하지만 val은 변경이 불가능하므로 게터만 제공합니다. 그래서 val은 var로 오버라이드 할 수 있습니다.)<br>
<b>val은 읽기 전용 프로퍼티지만 변경할 수 없음(불변, immutable)을 의미하는것은 아니라는것을 기억하시기 바랍니다.</b>

### 가변 컬렉션과 읽기 전용 컬렉션 구분하기
Iterable, Collection, Set, List 인터페이스는 읽기 전용이라 변경을 위한 메서드를 따로 가지지 않습니다.
MutableIterable, MutableCollection, MutableSet, MutableList 인터페이스는 읽고 쓸 수 있는 컬렉션 입니다.<br>
mutable이 붙은 인터페이스는 읽기 전용 인터페이스를 상속 받아서 변경을 위한 메서드를 추가한것입니다.<br>
읽기 전용 컬렉션이 내부의 값을 변경 할 수 없다는 의미는 아닙니다.<br>
<b>코틀린에서는 읽기 전용 콜렉션을 mutable 컬렉션으로 다운 캐스팅하면 안됩니다. 읽기 전용에서 mutable로 변경해야 한다면 복제(copy)를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList를 활용해야합니다.</b>

### 데이터 클레스의 copy
immutable 클레스를 생성할때 새로운 객체를 만들 수 있는 함수를 만들어야 한다. 하지만 data 한정자를 사용하면 copy라는 메서드를 활용 할 수 있게 된다.<br>
copy 메서드는 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있습니다.

## 다른 종류의 변경 가능 지점
구체적인 리스트 구현 내부에 변경 가능 지점이 있는 경우, 멀티스레드 처리가 이루어질 경우 내부적으로 적절한 동기화가 되어 있는지 확실하게 알 수 가 없기에 위험합니다.<br>
프로퍼티 자체가 변경 가능 지점일 경우, 멀티스레드 처리의 안정성이 더 좋다고 할 수 있습니다.(물론 잘못 만들면 일부 요소가 손실될 수도 있습니다.)<br>
상태를 변경 할수 있는 불필요한 방법은 만들지 않아야 합니다.<br>
따라서 가변성을 제한하는 것이 좋습니다.

## 변경 가능 지점 노출하지 말기
mutable 객체를 외부에 노출하는 것은 굉장히 위험합니다.<br>
이를 처리하기 위해서 리턴되는 mutable 객체를 복제하는것, 이를 방어적 복제라고 합니다.<br>
이때 data 한정자로 만들어지는 copy 메서드를 활용하면 좋습니다.<br>

// ??두번쨰는 어디갔지?

가능하다면 무조건 가변성을 제한하는 것이 좋습니다.<br>
컬렉션은 객체를 읽기 전용 슈퍼타입으로 업캐스트하여 가변성을 제한 할 수도 있습니다.

## 정리
가변성을 제한한 immutable 객체를 사용하는 것이 좋은 이유에 대해서 알아보았습니다.<br>
코틀린은 가변성을 제한하기 위해 다양한 도구들을 제공합니다.<br>
이를 활용해 가변 지점을 제한하며 코드를 작성하도록 합시다.

### 규칙 정리
- var 보다는 val을 사용하는 것이 좋습니다.
- mutable 프로퍼티보다는 immutable 프로퍼티를 사용하는 것이 좋습니다.
- mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용하는 것이 좋습니다.
- 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy를 활용하는 것이 좋습니다.
- 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용하는 것이 좋습니다.
- 변이 지점을 적절하게 설계하고, 불필요한 변이 지점을 만들지 않는 것이 좋습니다.
- mutable 객체를 외부에 노출하지 않는 것이 좋습니다.

### 예외
- 효율성 때문에 immutable 객체 보다 mutable 객체를 사용하는 것이 좋을 때가 있습니다.






