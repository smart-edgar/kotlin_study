# 아이템48. 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라

메모리 관리를 자동으로 해주는 프로그래밍 언어에 익숙한 개발자는 객체 해제를 따로 생각하지 않습니다.<br>
자바는 가비지 컬렉터가 객체 해재와 관련된 모든 작업을 해줍니다.<br>
하지만 그렇다고 메모리 관리를 완전히 무시해 버리면 메모리 누수가 발생해서 상황에 따라 OOM이 발생하기도 합니다.<br>
'더이상 사용하지 않는 객체의 레퍼런스를 유지하면 안된다'라는 규칙 정도는 지켜주는 것이 좋습니다.<br>
특히 어떤 객체가 메모리를 많이 차지하거나 어떤 객체의 인스턴스가 많이 생성 될 경우에는 규칙을 꼭 지켜줘야 합니다.

여러곳에서 자유롭게 접근하기 위해서 companion 프로퍼티(고전적인 형태로는 static 필드)에 할당해두는 경우가 있습니다.<br>
이럴경우 가비지 컬렉터가 해당 겍체에 대한 메모리 해제를 할 수 없습니다.

메모리 문제는 굉장히 미묘한 곳에서 발생하는 경우가 많습니다.
[fun01.kt](fun01.kt)<br>
이 코드는 pop를 할때 size를 감소시키기만 하고 배열 위의 요소를 해제하는 부분이 없습니다.<br>
스택에 1000개의 요소가 있을 경우 이어서 pop을 실행해서 size를 1까지 줄일 경우 요소 1개만 의미가 있고 나머지는 의미가 없습니다.<br>
하지만 코드 스택은 1000개의 요소를 모두 가지고 있습니다.<br>
가비지 컬렉터가 이를 해제하지 못합니다.<br>
999개의 요소가 메모리를 낭비하게 됩니다.

이러한 최적화 처리가 과연 중요할까요? 거의 사용되지 않는 객체까지 이러한것을 신경 쓰는 것은 오히려 좋지 않을수도 있습니다.<br>
'쓸데없는 최적화가 모든 악의 근원' 이라는 말도 있습니다.

하지만 오브젝트에 null을 설정하는 것은 그렇게 어려운 일이 아니므로 무조건 하는 것이 좋습니다.<br>
많은 변수를 캡처할 수 있는 함수타입, Any 또는 제네릭 타입과 같은 미지의 클래스일 때는 이러한 처리가 중요합니다.<br>
따라서 최적화에 더 신경을 써야 합니다.

일반적인 규칙은 상태를 유지할 때는 메모리 관리를 염두에 두어야 한다는 것입니다.<br>
코드를 작성할 때는 '메모리와 성능' 뿐만 아니라 '가독성과 확장성'을 항상 고려해야 합니다.<br>
일반적으로 가독성 좋은 코드는 메모리와 성능적으로도 좋습니다.<br>
일반적으로 가독성과 확장성을 더 중요시 하는 것이 좋습니다.<br>
예외적으로 라이브러리를 구현할 때는 메모리와 성능이 더 중요합니다.

절대 사용되지 않는 객체를 캐시해서 저장해 두는 경우 해결 방법은 소프트 레퍼런스를 사용하는것입니다.<br>
메모리 누수는 예측하기 어렵습니다.<br>
애플리케이션이 크래시 되기 전까지는 확인하기 힘들 수 도 있습니다.<br>
그래서 별도의 도구들을 활용해서 메모리 누수를 찾는 것도 좋은 방법입니다.<br>
가장 기본적인 도구로는 힙 프로파일러가 있습니다.<br>
또한 메모리 누수 탐색에 도움이 되는 라이브러리도 있습니다.<br>

객체를 수동으로 해제해야 하는 경우는 굉장히 드뭅니다.<br>
일반적으로 스코프를 벗어나면서 어떤 객체를 가리키는 레퍼런스가 제거될때 객체가 자동으로 해제됩니다.<br>
따라서 메모리와 관련된 문제를 피하는 가장 좋은 방법은 변수를 지역 스코프에 정의하고 톱레벨 프로퍼티 또는 객체 선언으로 데이터를 저장하지 않는것입니다.



## 정리
