# 아이템45. 불필요한 객체 생성을 피하라

JVM에서는 하나의 가상머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면 기존의 문자열을 재사용합니다.<br>

## 객체 생성 비용은 항상 클까?
객체를 랩(warp)하면 크게 세가지 비용이 발생합니다.
- 객체는 더 많은 용량을 차지합니다.
- 요소가 캡슐화되어 있다면 접근에 추가적인 함수 호출이 필요합니다.
- 객체는 생성되어야 합니다.

객체를 제거하면 세가지 비용을 모두 피할수 있습니다.<br>
특히 객체를 재사용하면 첫번째와 세번째 비용을 제거할 수 있습니다.<br>
이를 알면 코드에서 불필요한 객체를 어떤 식으로 제거해야 하는지 알수 있습니다.


## 객체 선언
매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것입니다.(싱글톤)<br>

[fun04.kt](fun04.kt)<br>
immutable sealed 클래스를 정의할때 자주 사용합니다.<br>
mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 검출하기 어려울수 있으므로 좋지 않습니다.

## 캐시를 활용하는 팩토리 함수
객체는 생성자를 사용해서 만듭니다.<br>
하지만 팩토리 메서드를 사용해서 만드는 경우도 있습니다.<br>
팩토리 함수는 캐시를 가질 수 있습니다.<br>
팩토리 함수는 항상 같은 객체를 리턴하게 만들 수 도 있습니다.

parameterized 팩토리 메서드도 캐싱을 활용할 수 있습니다.<br>
모든 순수 함수는 캐싱을 활용할 수 있습니다.<br>
이를 메모이제이션(memoization)이라고 부릅니다.

[fun06.kt](fun06.kt)<br>
피보나치 수는 추가적인 계산 없이 바로 구해집니다.<br>
재귀함수로 구현했지만 반복문을 사용해서 구현(선형 방법으로 구현)하는 것만큼 효율적입니다.<br>

재귀 함수는 처음 사용할때 피보나치 수를 구하는 오버헤드가 커서 반복문을 사용한 방식보다 시간이 더 오래 걸리는것을 알수 있습니다.<br>
하지만 값이 한번 계산되면 값을 즉시 구해줍니다.<br>

다만 큰 단점이 있습니다.<br>
캐시를 위한 Map을 저장해야하므로 더 많은 메모리를 사용합니다.<br>

WeakReference 와 SoftReference 의 차이
- WeakReference는 가비지 컬렉터가 값을 정리하는 것을 막지 않습니다.
- SoftReference는 가미지 컬렉터가 값을 정리할 수도 있고 정리하지 않을 수도 있습니다.

캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로 캐시를 잘 설계하는 것은 쉽지 않습니다.


## 무거운 객체를 외부 코스프로 보내기
성능을 위한 굉장히 유용한 트릭으로 무거운 객체를 외부 스코프로 보내는 방법이 있습니다.<br>
컬렉션 처리에서 이루어지는 무거운 연산은 컬렉터 처리 함수 내부에서 외부로 빼는 것이 좋습니다.

[fun08.kt](fun08.kt)
함수가 한 파일에 다른 함수와 함께 있을때 함수를 사용하지 않는다면 정규 표현식이 만들어지는 것 자체가 낭비입니다.<br>
이런경우에는 지연 초기화를 하면 됩니다.

프로퍼티를 지연되게 만드는 것은 무거운 클래스를 사용할 때 유용합니다.

## 지연 초기화
무거운 클래스를 만들 때는 지연되게 만드는 것이 좋을때가 있습니다.
지연 초기화를 이용하면 클래스를 생성하는 과정을 가볍게 만들수 있습니다.

지연초기화의 단점은 클래스가 무거운 객체를 가졌지만 메서드의 호출은 빨라야 하는 경우가 있을수 있습니다.<br>
백엔드 어플리케이션에서 지연되게 만들면 첫번째 호출때 응답 시간이 굉장히 길것입니다.<br>
그래서 백엔드 어플리케이션에서 좋지 않을 수 있습니다.<br>
또한 성능 테스트가 복잡해지는 문제가 있습니다.


## 기본 자료형 사용하기
JVM은 숫자와 문자등의 기본적인 요소를 나타내기 위한 특별한 기본 내장 자료형을 가지고 있습니다.<br>
이를 기본 자료형(primitives)이라고 부릅니다.<br>

1. nullable 타입을 연산할 때(기본 자료형은 null일 수 없으므로)
2. 타입을 제네릭으로 사용할 때

코틀린의 자료형 | 자바의 자료형<br>
Int | int<br>
Int? | Integer<br>
List<Int> | List<Integer><br>

랩한 자료형 대신 기본 자료형을 사용하게 코드를 최적화 할수 있습니다.<br>
코틀린/JVM, 일부 코틀린/Native 버전에서만 의미가 있고 코틀린/JS에서는 의미가 없습니다.

[fun09.kt](fun09.kt)<br>
위 구현의 두가지 심각한 단점
- 각각의 단계에서 엘비스 연산자를 사용해야합니다.
- nullable 값을 사용했기 때문에 JVM 내부에서 int가 아니라 Integer로 연산이 일어납니다.

라이브러리를 구현한다면 성능이 중요할 수 있습니다.


## 정리
객체를 생성할때 발생할 수 있는 문제를 피하는 방법에 대해 살펴봤습니다.<br>
가독성을 향상시켜 주는 장점도 있으므로 적극적으로 사용하는 것이 좋습니다.<br>
'무거운 객체를 외부 스코프로 보내기'는 성능도 향상시켜 주고 객체에 이름을 붙여서 함수 내부에서 사용하므로 함수를 더 쉽게 읽을 수 있게 해줍니다.<br>

성능이 중요한 코드에서 성능을 조금이라도 향상 시킬 수 있는 방법에 대해서도 배웠습니다.<br>
이러한 최적화에 큰 변경이 필요하거나 다른 코드에 문제를 일으킬수 있다면 최적화를 미루는 것도 방법입니다.
