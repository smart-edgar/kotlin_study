# 아이템46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라

표준라이브러리의 고차 함수를 살펴보면 대부분 inline 한정자가 붙어 있는 것을 확인할 수 있습니다.<br>
inline 한정자의 역활은 컴파일 시점에 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하는 것 입니다.

이처럼 inline 한정자를 붙여 함수를 만들면 굉장히 큰 변화가 일어납니다.<br>
일반적인 함수를 호출하면 함수 본문으로 점프하고 본문의 모든 문장을 호출한 뒤에 호출했던 위치로 다시 점프하는 과정을 거칩니다.<br>
하지만 inline을 사용하면 점프라 일어나지 않습니다.

inline의 장점
- 아규먼트에 reified 한정자를 붙여서 사용할 수 있습니다.
- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작합니다.
- 비지역(non-local) 리턴을 사용할 수 있습니다.

## 타입 아규먼트를 reified로 사용할 수 있다
JVM바이트 코드에서 제네릭이 존재하지 않습니다.<br>
따라서 컴파일을 하면 제네릭 타입과 관련된 내용이 제거됩니다.<br>

함수를 인라인으로 만들면 이러한 제한을 무시할 수 있습니다.<br>
함수 호출이 본문으로 대체되므로 reified 한정자를 지정하면 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체됩니다.

## 함수 타입 파라미터를 가진 함수가 훨씬 바르게 동작한다
모든 함수는 inline 한정자를 붙이면 조금 더 빠르게 동작합니다.<br>
함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문입니다.<br>
표준 라이브러리에 있는 간단한 함수들에는 대부분 inline 한정자가 붙어 있습니다.

하지만 함수 파라미터를 가지지 않는 함수에서는 이러한 차이가 큰 성능 차이를 발생시키지 않습니다.<br>
간단한 함수에 inline을 붙일 경우 인텔리제이가 경고를 표시합니다.

함수를 객체로서 조작할 때 발생하는 문제를 이해해야 합니다.<br>
함수 리터럴을 사용해 만들어진 이러한 종류의 객체는 어떤 방식으로든 저장되고 유지되어야 합니다.<br>
코틀린/JVM에서는 JVM 익명 클래스 또는 일반 클래스를 기반으로 함수를 객체로 만들어 냅니다.

JVM에서 아규먼트가 없는 함수 타입은 Function0 타입으로 변환됩니다.<br>
다른 타입의 함수는 다음과 같은 형태로 변환됩니다.
- () -> Unit는 Function0<Unit>로 컴파일
- () -> Int는 Function0<Int>로 컴파일
- (Int) -> Int는 Function1<Int, Int>로 컴파일
- (Int, Int) -> Int는 Function2<Int, Int, Int>로 컴파일

이러한 모든 인터페이스는 모두 코틀린 컴파일러에 의해서 생성됩니다.<br>
요청이 있을때 생성되므로 명시적으로 사용할 수는 없습니다.<br>
대신 함수 타입을 사용할 수 있습니다.<br>
함수 타입이 단순한 인터페이스라는 것을 알면 추가적인 기능성들이 보이게 됩니다.

[fun04.kt](fun04.kt)<br>
첫번째 함수는 숫자로 반복을 돌면서 빈 함수를 호출합니다.<br>
두번째 함수는 숫자로 반복을 돌면서 객체를 호출하고 이 객체가 빈 함수를 호출합니다.<br>
코드의 실해애 방식 차이로 인해 속도 차이가 발생하는것입니다.

'인라인 함수'와 '인라인 함수가 아닌 함수'의 더 중요한 차이는 함수 리터럴 내부에서 지역 변수를 캡처할 때 확인할 수 있습니다.<br>
캡처된 값은 객체로 래핑해야 하며 사용할 때마다 객체를 통해 작업이 이루어져야 합니다.

함수가 객체로 컴파일되고 지역 변수가 래핑되어 발생하는 문제가 누적된 결과입니다.<br>
일잔적으로 함수 타입의 파라미터가 어떤 식으로 동작하는지 이해하기 어려우므로 함수 타입 파라미터를 활용해서 유틸리티 함수를 만들때는 그냥 인라인을 붙여 준다 생각하는것도 좋습니다.<br>
이러한 이유로 표준 라이브러리가 제공하는 대부분의 함수 타입 파라미터를 가진 확장 함수는 인라인으로 정의합니다.

## 비지역적 리턴(non-local return)을 사용할 수 있다
non inline은 내부에서 리턴을 사용할 수 없습니다.<br>
함수 리터럴이 컴파일 될때 함수가 객체로 래핑되어 발생하는 문제입니다.<br>
함수가 다른 클래스에 위치하므로 return을 사용해서 main으로 돌아올수 없는 것입니다.<br>
인라인 함수라면 이런 제한이 없습니다.<br>
함수가 main 함수 내부에 대체되어 있기 때문입니다.

## inline 한정자의 비용
inline 한정자는 굉장히 유용한 한정자이지만 모든곳에 사용할 수는 없습니다.<br>
대표적인 예로 인라인 함수는 재귀적으로 동작할 수 없습니다.<br>
재귀적으로 사용하면 무한하게 대체되는 문제가 발생합니다.<br>
이러한 문제는 인텔리제이가 오류로 잡아주지 못하므로 굉장히 위험합니다.

또한 인라인 함수는 더 많은 가시성 제한을 가진 요소를 사용할 수 없습니다.<br>
public 인라인 함수 내부에서 private과 internal 가시성을 가진 함수와 프로퍼티를 사용할 수 없습니다.<br>
이처럼 인라인 함수는 구현을 숨길수 없으므로 클래스에 거의 사용되지 않는것입니다.

inline 한정자를 남용하면 코드의 크기가 쉽게 커집니다.<br>
서로 호출하는 인라인 함수가 많아지면 코드가 기하급수적으로 증가하므로 위험합니다.

## crossinline과 noinline
함수를 인라인으로 만들고 싶지만 어떤 이유로 일부 함수 타입 파라미터는 inline으로 받고 싶지 않은 경우가 있을수 있습니다.
- crossinline : 아규먼트로 인라인 함수를 받지만 비지역적 리턴을 하는 함수는 받을 수 없게 만듭니다. 인라인으로 만들지 않은 다른 람다 표현식과 조합해서 사용할 때 문제가 발생하는 경우 활용합니다.
- noinline : 아규먼트로 인라인 함수를 받을 수 없게 만듭니다. 인라인 함수가 아닌 함수를 아규먼트로 사용하고 싶을 때 활용합니다.


## 정리
인라인 함수가 사용되는 주요 사례를 정리해보면 다음과 같습니다.
- print 함수처럼 매우 ㅈ많이 사용되는 경우
- filterIsInstance 함수처럼 타입 아규먼트로 reified 타입을 전달받는 경우
- 함수 타입 파라미터를 갖는 톱레벨 함수를 정의해야 하는 경우, 특히 컬렉션 처리 함수와 같은 헬퍼 함수(map, filter, flatMap, joinToString 등), 스코프 함수(also, apply, let 등), 톱레벨 유틸리티 함수(repeat, run, with)의 경우

API를 정의할때 인라인 함수를 사용하는 경우는 거의 없습니다.<br>
한 인라인 함수가 다른 인라인 함수를 호출하는 경우, 코드가 기하급수적으로 많아질수 있으므로 주의하세요.
